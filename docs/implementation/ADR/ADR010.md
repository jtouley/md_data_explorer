# ADR010: Migration from Streamlit to Lightweight Web UI

**Status**: Proposed
**Date**: 2026-01-03
**Decision Makers**: Engineering Team
**Related ADRs**: ADR001 (Multi-table support), ADR009 (LLM-Enhanced UX)

## Context

The clinical analytics platform currently uses Streamlit as its UI framework. While Streamlit enabled rapid prototyping and quick iteration during MVP development, several limitations have emerged as the platform has matured:

### Current Pain Points

1. **State Management Fragility**
   - `st.session_state` acts as a mini state machine with no validation
   - State persists incorrectly across dataset changes causing UI bugs
   - No type safety or schema validation for session state
   - Documented in `Ask_Questions.py` lines 1584-1610 as known fragility

2. **Performance Constraints**
   - Full page reruns on every interaction (`st.rerun()`)
   - No incremental rendering or DOM diffing
   - Heavy widget rendering overhead for large chat transcripts
   - `@st.cache_resource` required for non-picklable objects (DuckDB/Ibis)

3. **User Experience Limitations**
   - No session history browsing or search
   - Cannot open multiple conversations in tabs
   - No dark mode support
   - Poor mobile responsiveness
   - Chat interface lacks modern UX patterns (collapsible sections, streaming indicators)

4. **Development Constraints**
   - Limited testability (widget state difficult to mock)
   - No component reusability outside Streamlit
   - Difficult to add custom interactions or animations
   - Streamlit updates can break UI (version coupling)

5. **Deployment Complexity**
   - Streamlit server required for hosting
   - No static site generation or CDN deployment
   - Difficult to scale horizontally (session affinity required)
   - No API-first architecture for future mobile/CLI clients

### Trigger for Change

Recent features (LLM-enhanced UX in ADR009, multi-table support in ADR001) have pushed Streamlit to its limits:
- Chat transcript management requires complex state machine logic
- Result caching uses custom LRU eviction to work around Streamlit limitations
- Variable selection UI requires careful rerun orchestration
- Trust UI (patient-level export) needs custom download handling

The platform has outgrown Streamlit's rapid prototyping strengths and now needs production-grade UI architecture.

## Decision

We will migrate from Streamlit to a **FastAPI backend + Next.js frontend architecture** with the following characteristics:

### Architecture Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                          Web Frontend                            │
│                     (Next.js 15 + TypeScript)                   │
│                                                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐         │
│  │ Conversation │  │    Chat      │  │   Dataset    │         │
│  │     List     │  │  Interface   │  │   Selector   │         │
│  └──────────────┘  └──────────────┘  └──────────────┘         │
│                                                                  │
│  ┌────────────────────────────────────────────────────┐         │
│  │         Result Renderers (6 analysis types)        │         │
│  └────────────────────────────────────────────────────┘         │
└─────────────────────────────────────────────────────────────────┘
                               │
                               │ REST API + SSE
                               ▼
┌─────────────────────────────────────────────────────────────────┐
│                        FastAPI Backend                           │
│                         (Python 3.11+)                          │
│                                                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐         │
│  │   Session    │  │   Dataset    │  │    Query     │         │
│  │  Management  │  │  Management  │  │     API      │         │
│  └──────────────┘  └──────────────┘  └──────────────┘         │
│                                                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐         │
│  │Conversation  │  │    Result    │  │    Query     │         │
│  │   Manager    │  │    Cache     │  │   Service    │         │
│  └──────────────┘  └──────────────┘  └──────────────┘         │
└─────────────────────────────────────────────────────────────────┘
                               │
                               │ Reuse existing logic
                               ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Core Business Logic                          │
│                         (No changes)                            │
│                                                                  │
│  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐   │
│  │ Question Engine│  │ Result Interp. │  │ Semantic Layer │   │
│  └────────────────┘  └────────────────┘  └────────────────┘   │
│                                                                  │
│  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐   │
│  │ NL Query Engine│  │  Stats/Survival│  │   DuckDB/Ibis  │   │
│  └────────────────┘  └────────────────┘  └────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### Key Design Decisions

1. **Backend: FastAPI**
   - **Rationale**: Python-based (reuse existing logic), async support, OpenAPI docs, SSE support
   - **Alternatives considered**: Flask (no async), Django (too heavy)
   - **Trade-offs**: New dependency, but gains API-first architecture

2. **Frontend: Next.js**
   - **Rationale**: React ecosystem, TypeScript support, excellent DX, App Router for modern patterns
   - **Alternatives considered**: Vanilla React (more setup), SvelteKit (different ecosystem)
   - **Trade-offs**: Adds Node.js toolchain, but gains modern UI capabilities

3. **State Management: Server-Side Sessions**
   - **Rationale**: Avoid Streamlit's fragile `session_state`, enable multi-tab browsing
   - **Implementation**: SQLite for MVP (easy migration to Postgres later)
   - **Trade-offs**: Database dependency, but gains persistence and reliability

4. **Real-Time Updates: SSE (Server-Sent Events)**
   - **Rationale**: One-way streaming (server → client), simpler than WebSockets for this use case
   - **Usage**: Stream query execution progress, intermediate results
   - **Trade-offs**: No client→server streaming, but sufficient for current needs

5. **Styling: TailwindCSS**
   - **Rationale**: Utility-first, dark mode support, responsive out of box
   - **Alternatives considered**: Styled Components (more verbose)
   - **Trade-offs**: Learning curve, but gains rapid UI development

6. **Plotting: Backend Data + Frontend Rendering**
   - **Rationale**: Separation of concerns, responsive rendering, no image bandwidth
   - **Implementation**:
     - Backend generates plot data as JSON (e.g., `{time: [], survival: [], ci_lower: [], ci_upper: []}`)
     - Frontend renders with Recharts (LineChart for survival, custom heatmap component)
   - **Alternatives considered**: Backend PNG generation (poor UX), client-side matplotlib (not possible)
   - **Trade-offs**: More frontend code, but gains interactivity and responsiveness

7. **Caching: Redis (production) + in-memory (dev)**
   - **Rationale**: Result cache needs TTL, LRU eviction, persistence
   - **Implementation**: FastAPI dependency injection, async access
   - **Trade-offs**: External service dependency (production), but gains scalability

### What Changes

**New Components**:
- FastAPI application with routes, services, models, DB layer
- Next.js web application with React components
- SQLite database for session persistence
- Alembic migrations for schema management
- Jest + Playwright test suites for frontend
- Makefile targets: `make dev-web`, `make dev-api`, `make test-web`, `make test-e2e`

**Extracted and Reused**:
- `components/question_engine.py` → `api/services/query_service.py` (wraps existing logic)
- `components/result_interpreter.py` → `api/services/interpretation_service.py`
- Session state logic → `api/services/conversation_manager.py`
- Result caching logic → `api/services/result_cache.py`
- All `core/` modules (semantic layer, NL engine) → used directly via FastAPI dependency injection
- All `analysis/` modules (stats, survival) → used directly

**Deprecated**:
- `ui/app.py` and all `ui/pages/*.py` → archived to `archive/streamlit_ui/`
- Streamlit-specific components → ported to React components
- `@st.cache_resource` patterns → replaced with FastAPI `Depends()`
- `st.session_state` → replaced with SQLite-backed sessions

**Unchanged**:
- All business logic in `core/` and `analysis/` modules
- Data processing (Polars, DuckDB, Ibis)
- LLM integration (Ollama, Claude)
- Dataset definitions and loaders
- Test fixtures in `tests/conftest.py` (reused for API tests)

### Migration Strategy

**Phase 1: Parallel Development** (Weeks 1-2)
- Build FastAPI backend alongside existing Streamlit UI
- Extract ConversationManager, ResultCache from session_state logic
- No user impact (Streamlit still runs)

**Phase 2: Feature Parity** (Weeks 2-4)
- Port all 8 pages to Next.js components
- Implement all 6 analysis type renderers
- Add Trust UI, follow-up suggestions, variable mapping
- Internal testing with feature flag

**Phase 3: Cutover** (Week 4)
- Deploy with `ENABLE_NEW_UI=true` feature flag
- Monitor for critical bugs (rollback if >3 in 48h)
- Archive Streamlit code to `archive/streamlit_ui/`

**Phase 4: Cleanup** (Week 5)
- Remove Streamlit dependencies from `pyproject.toml`
- Update documentation (README, setup guides)
- Remove feature flag after stabilization

### Rollback Plan

- **Trigger**: >3 critical bugs within 48h of cutover
- **Process**:
  1. Set `ENABLE_NEW_UI=false` (reverts to Streamlit)
  2. Investigate and fix issues
  3. Re-deploy new UI when ready
- **Data safety**: Sessions stored in SQLite during new UI, read-only access to Streamlit session files

## Consequences

### Positive

1. **Better Performance**
   - Incremental rendering (React diffing)
   - No full-page reruns
   - Static asset optimization (Next.js)
   - API caching with React Query

2. **Improved User Experience**
   - Session history browsing and search (like claude-run)
   - Multi-tab support (no session affinity issues)
   - Dark mode
   - Mobile-responsive design
   - Modern chat UX (collapsible sections, streaming indicators)

3. **Enhanced Testability**
   - API contracts testable in isolation (FastAPI TestClient)
   - Frontend components testable with Jest + React Testing Library
   - E2E flows testable with Playwright
   - Better separation of concerns (UI vs business logic)

4. **Future-Proof Architecture**
   - API-first enables future mobile/CLI clients
   - TypeScript types auto-generated from OpenAPI schema
   - Component reusability across potential future products
   - Easier to add features (no Streamlit limitations)

5. **Developer Experience**
   - Hot module replacement (Next.js dev server)
   - Better IDE support (TypeScript)
   - Modern debugging tools (React DevTools)
   - Clearer separation of concerns

### Negative

1. **Increased Complexity**
   - Two codebases (backend + frontend) vs one Streamlit app
   - Node.js toolchain added (npm/pnpm, TypeScript, build process)
   - More deployment moving parts (API server + static site)

2. **Learning Curve**
   - Team needs React/Next.js knowledge (currently Python-focused)
   - Frontend testing patterns (Jest/Playwright) different from pytest
   - SSE debugging more complex than Streamlit reruns

3. **Development Velocity Impact**
   - Initial slowdown during migration (4-5 weeks estimated)
   - Two-sided changes required (API + frontend) for new features
   - More boilerplate for simple features

4. **Operational Overhead**
   - Database required (SQLite for dev, Postgres for production)
   - Redis for caching (production)
   - More services to monitor and maintain

### Mitigation Strategies

1. **Complexity**: Use claude-run as reference implementation, follow established patterns
2. **Learning curve**: Pair programming sessions, code reviews, documentation
3. **Velocity**: Keep Streamlit code in archive for reference during migration
4. **Operations**: Start with SQLite (file-based, no extra service), migrate to Postgres/Redis only when needed

## Implementation Plan

Detailed 60-step implementation plan with TDD workflow: `.cursor/plans/streamlit_to_lightweight_ui_refactor_4iMKv.plan.md`

### Critical Path

1. **Phase 1.5**: Verify semantic layer compatibility with FastAPI (DuckDB async, Ibis dependency injection)
2. **Phase 2-4**: Build backend API (session, dataset, query endpoints) with TDD
3. **Phase 5-6**: Build frontend components (conversation list, chat, renderers) with Jest tests
4. **Phase 7**: Upload flow and variable mapping wizard
5. **Phase 8**: Integration testing (end-to-end flows)
6. **Phase 9**: Deployment and documentation

### Success Criteria

1. ✅ All 8 Streamlit pages ported to new UI
2. ✅ All 6 analysis types working (DESCRIBE, COMPARE_GROUPS, FIND_PREDICTORS, EXAMINE_SURVIVAL, EXPLORE_RELATIONSHIPS, COUNT)
3. ✅ Session persistence and browsing (search, filter by dataset/date)
4. ✅ Real-time SSE streaming for query execution with progress indicators
5. ✅ Dark mode support with theme persistence
6. ✅ All existing tests passing + new API/frontend tests
7. ✅ Documentation updated (README, setup guides, architecture diagrams)
8. ✅ Performance >= Streamlit (faster page loads, no reruns, <500ms API latency for simple queries)

### Quality Gates

- **Phase 2 Done**: All API routes return 200/201, OpenAPI docs generated, unit tests pass
- **Phase 5 Done**: All components render without errors, basic interaction tests pass
- **Phase 8 Done**: End-to-end flow (upload → query → results → export) works, integration tests pass
- **Final Gate**: `make check-fast` passes (backend + frontend tests), type-check clean, no new lint errors

## Risks and Open Questions

### Risks

1. **Risk**: Semantic layer (DuckDB/Ibis) incompatible with FastAPI async patterns
   - **Likelihood**: Medium
   - **Impact**: High (blocks entire migration)
   - **Mitigation**: Phase 1.5 explicitly tests this compatibility before building API routes

2. **Risk**: Users expect conversation history to persist across migration
   - **Likelihood**: High
   - **Impact**: Medium (UX disappointment)
   - **Mitigation**: Document clearly: "Migration launches with empty history, existing Streamlit sessions archived read-only"

3. **Risk**: Plotting migration (matplotlib → Recharts) reveals edge cases
   - **Likelihood**: Medium
   - **Impact**: Medium (feature gaps)
   - **Mitigation**: Explicit plotting strategy documented in Key Design Decisions

4. **Risk**: Timeline underestimated (19-28 days → could be 35-40 days)
   - **Likelihood**: Medium
   - **Impact**: Low (not blocking, just slower)
   - **Mitigation**: Phased rollout allows incremental delivery

### Open Questions

1. **Q**: Should session migration be required or optional?
   - **A**: Optional for MVP, document as "clean slate" launch

2. **Q**: Deploy both UIs during transition or hard cutover?
   - **A**: Feature flag deployment (`ENABLE_NEW_UI` env var) for safe rollback

3. **Q**: Use Redis for caching in dev or only production?
   - **A**: In-memory dict for dev (simpler), Redis for production (scalable)

4. **Q**: Generate TypeScript types from Pydantic models or manually maintain?
   - **A**: Auto-generate from OpenAPI schema (todo #14.5)

## References

- [claude-run](https://github.com/kamranahmedse/claude-run) - UI inspiration for session browsing, SSE, dark mode
- [FastAPI Documentation](https://fastapi.tiangolo.com/) - Backend framework
- [Next.js Documentation](https://nextjs.org/docs) - Frontend framework
- [SSE with FastAPI](https://github.com/sysid/sse-starlette) - Server-sent events library
- Current codebase analysis (Ask_Questions.py state machine documented in lines 1537-1702)

## Approval

- [ ] Engineering lead review
- [ ] Product stakeholder review
- [ ] Security review (API authentication, input validation)
- [ ] Plan review completed (Staff Engineer feedback in plan file)

## Revision History

- **2026-01-03**: Initial proposal (ADR010 created)
- **2026-01-03**: Staff Engineer review feedback added to plan file
