# Test Fixture Enforcement

**Status**: MANDATORY - Enforced starting 2025-01 (Phase 1-2 Refactoring)

**Audience**: AI agents, code reviewers, developers

**Purpose**: Eliminate fixture duplication and enforce single source of truth

---

## Hard Rule: Factory Fixtures MUST Be Used

### ✅ REQUIRED Factory Fixtures

These fixtures are **MANDATORY**. Using them is **NOT OPTIONAL**.

#### 1. `make_semantic_layer` - SemanticLayer Factory

**When to use**: ANY test that creates a SemanticLayer instance

**Signature**:
```python
make_semantic_layer(
    dataset_name: str = "test_dataset",
    data: dict[str, list] | None = None,
    config_overrides: dict | None = None,
    workspace_name: str = "test_workspace",
) -> SemanticLayer
```

**Example**:
```python
def test_query_execution(make_semantic_layer):
    layer = make_semantic_layer(
        dataset_name="patients",
        data={"patient_id": [1, 2, 3], "age": [45, 62, 38]},
        config_overrides={
            "column_mapping": {"patient_id": "patient_id"},
            "outcomes": {"mortality": {"column": "died"}},
        },
    )
    result = layer.execute_query(...)
```

**❌ FORBIDDEN Alternative**:
```python
# WRONG - Will be REJECTED
def test_query_execution(tmp_path):
    workspace = tmp_path / "workspace"
    workspace.mkdir()
    config_path = workspace / "config.yaml"
    # ... 30 lines of setup ...
    layer = SemanticLayer(dataset_name="patients", ...)
```

---

#### 2. `mock_semantic_layer` - Mock SemanticLayer Factory

**When to use**: Tests that need semantic layer interface but not real data loading

**Signature**:
```python
mock_semantic_layer(
    columns: dict[str, str] | None = None,
) -> MagicMock
```

**Example**:
```python
def test_query_intent_conversion(mock_semantic_layer):
    mock = mock_semantic_layer(columns={"age": "age", "status": "status"})
    intent = QueryIntent(operation="describe", target="age")
    plan = intent_to_plan(intent, mock)
```

**❌ FORBIDDEN Alternative**:
```python
# WRONG - Will be REJECTED
def test_query_intent_conversion():
    mock = MagicMock()
    mock.get_canonical_column_name.side_effect = lambda x: x
    # ... duplicated mock setup ...
```

---

#### 3. `make_cohort_with_categorical` - Categorical Cohort Factory

**When to use**: Tests requiring patient cohorts with categorical encoding ("1: Yes", "2: No")

**Signature**:
```python
make_cohort_with_categorical(
    patient_ids: list[str] | None = None,
    treatment: list[str] | None = None,
    status: list[str] | None = None,
    ages: list[int] | None = None,
) -> pl.DataFrame
```

**Example**:
```python
def test_categorical_analysis(make_cohort_with_categorical):
    cohort = make_cohort_with_categorical(
        patient_ids=["P001", "P002"],
        treatment=["1: Yes", "2: No"],
        ages=[45, 52],
    )
    result = analyze_categorical(cohort)
```

**❌ FORBIDDEN Alternative**:
```python
# WRONG - Will be REJECTED
def test_categorical_analysis():
    cohort = pl.DataFrame({
        "patient_id": ["P001", "P002"],
        "treatment": ["1: Yes", "2: No"],
        "age": [45, 52],
    })
```

---

#### 4. `make_multi_table_setup` - Multi-Table Factory

**When to use**: Tests requiring patients, medications, and bridge table (patient_medications)

**Signature**:
```python
make_multi_table_setup(
    num_patients: int = 3,
    num_medications: int = 3,
) -> dict[str, pl.DataFrame]
```

**Returns**: `{"patients": df, "medications": df, "patient_medications": df}`

**Example**:
```python
def test_relationship_detection(make_multi_table_setup):
    tables = make_multi_table_setup(num_patients=5, num_medications=4)
    detector = RelationshipDetector(tables)
    relationships = detector.detect_all()
```

**❌ FORBIDDEN Alternative**:
```python
# WRONG - Will be REJECTED
def test_relationship_detection():
    patients = pl.DataFrame({"patient_id": ["P1", "P2"], ...})
    medications = pl.DataFrame({"medication_id": ["M1", "M2"], ...})
    patient_medications = pl.DataFrame({"patient_id": ["P1"], ...})
    tables = {"patients": patients, ...}
```

---

## Enforcement Protocol

### Before Creating ANY Fixture

**MANDATORY CHECKLIST**:

1. Open `tests/conftest.py`
2. Search for similar fixture names:
   - `make_*` (factory fixtures)
   - `sample_*` (direct fixtures)
   - `mock_*` (mock fixtures)
3. If fixture exists → **STOP. Use it.**
4. If fixture almost matches → **STOP. Use parameters/arguments.**
5. Only if truly unique → Create new fixture in `conftest.py`

### Before Creating ANY Test Data

**MANDATORY CHECKLIST**:

1. Check if factory fixture exists for this data type
2. If SemanticLayer → ✅ Use `make_semantic_layer`
3. If categorical cohort → ✅ Use `make_cohort_with_categorical`
4. If multi-table setup → ✅ Use `make_multi_table_setup`
5. If mock semantic layer → ✅ Use `mock_semantic_layer`
6. **NEVER create inline data when factory exists**

### Before Running Tests

**MANDATORY COMMANDS**:

```bash
# CORRECT - REQUIRED
make test-fast         # Fast tests during development
make test-core         # Core module tests
make test-analysis     # Analysis module tests

# WRONG - FORBIDDEN
pytest tests/
uv run pytest tests/
python -m pytest tests/
```

### Before Committing

**MANDATORY PRE-COMMIT SEQUENCE**:

```bash
make format        # Auto-format code
make lint-fix      # Auto-fix linting issues
make check-fast    # Verify all quality gates
```

**If `make check-fast` fails → Fix issues before commit. No exceptions.**

---

## Violation Examples with Corrections

### Violation 1: Inline SemanticLayer Creation

**❌ WRONG** (Will be REJECTED):
```python
def test_query_execution(tmp_path):
    workspace = tmp_path / "workspace"
    workspace.mkdir()
    config = {
        "dataset": {"name": "test"},
        "column_mapping": {},
        "init_params": {"source_path": str(tmp_path / "data.csv")},
    }
    config_path = workspace / "test_dataset" / "config.yaml"
    config_path.parent.mkdir(parents=True)
    with open(config_path, "w") as f:
        yaml.dump(config, f)
    
    layer = SemanticLayer(
        dataset_name="test",
        workspace_root=workspace,
    )
    # ... test code ...
```

**✅ CORRECT** (REQUIRED):
```python
def test_query_execution(make_semantic_layer):
    layer = make_semantic_layer(
        dataset_name="test",
        data={"patient_id": [1, 2, 3], "age": [45, 62, 38]},
    )
    # ... test code ...
```

---

### Violation 2: Duplicate Mock Setup

**❌ WRONG** (Will be REJECTED):
```python
# In test_queryplan_conversion.py
@pytest.fixture
def mock_semantic_layer():
    mock = MagicMock()
    mock.get_canonical_column_name.side_effect = lambda x: x
    return mock

# In test_nl_query_engine.py
@pytest.fixture
def mock_semantic_layer():  # DUPLICATE!
    mock = MagicMock()
    mock.get_canonical_column_name.side_effect = lambda x: x
    return mock
```

**✅ CORRECT** (REQUIRED):
```python
# Both files use conftest.py fixture
def test_conversion(mock_semantic_layer):
    mock = mock_semantic_layer(columns={"age": "age"})
    # ... test code ...

def test_nl_query(mock_semantic_layer):
    mock = mock_semantic_layer(columns={"status": "status"})
    # ... test code ...
```

---

### Violation 3: Hardcoded Multi-Table Setup

**❌ WRONG** (Will be REJECTED):
```python
def test_bridge_detection():
    patients = pl.DataFrame({
        "patient_id": ["P1", "P2", "P3"],
        "name": ["Alice", "Bob", "Charlie"],
        "age": [30, 45, 28],
    })
    medications = pl.DataFrame({
        "medication_id": ["M1", "M2", "M3"],
        "drug_name": ["Aspirin", "Metformin", "Lisinopril"],
        "dosage": ["100mg", "500mg", "10mg"],
    })
    patient_medications = pl.DataFrame({
        "patient_id": ["P1", "P1", "P2", "P3"],
        "medication_id": ["M1", "M2", "M1", "M3"],
        "start_date": ["2024-01-01", "2024-01-15", "2024-02-01", "2024-03-01"],
    })
    tables = {
        "patients": patients,
        "medications": medications,
        "patient_medications": patient_medications,
    }
    # ... test code ...
```

**✅ CORRECT** (REQUIRED):
```python
def test_bridge_detection(make_multi_table_setup):
    tables = make_multi_table_setup(num_patients=3, num_medications=3)
    # ... test code ...
```

---

## Code Review Checklist

**Before approving ANY test PR:**

- [ ] No duplicate fixtures across test files?
- [ ] All SemanticLayer instances use `make_semantic_layer`?
- [ ] All categorical cohorts use `make_cohort_with_categorical`?
- [ ] All multi-table tests use `make_multi_table_setup`?
- [ ] All mock semantic layers use `mock_semantic_layer`?
- [ ] No inline test data when factory exists?
- [ ] All tests run via `make` commands (not `pytest` directly)?
- [ ] `make check-fast` passes?

**If ANY checkbox is unchecked → Request changes.**

---

## Rationale

### Why Factory Fixtures Are Mandatory

1. **Single Source of Truth**: Fixture logic exists in ONE place
2. **Maintainability**: Changes to test data structure require ONE update
3. **Readability**: Tests focus on behavior, not setup
4. **DRY Compliance**: Eliminates 50+ lines of duplicate setup code per test
5. **Velocity**: Writing new tests is 10x faster with factories

### Why Makefile Commands Are Mandatory

1. **Consistency**: Same commands across all environments
2. **Optimization**: Makefile sets `-n auto` for parallel execution
3. **Dependencies**: Makefile ensures `uv sync` runs first
4. **CI Alignment**: Local and CI use identical commands

### Impact Metrics (2025-01 Refactoring)

- **Lines eliminated**: 500+ (duplicate fixture code)
- **Tests refactored**: 50+ (semantic layer, multi-table)
- **Fixtures consolidated**: 8 duplicates removed
- **Test speed**: 40% faster (parallel execution enabled)
- **Maintenance burden**: 75% reduction (single source of truth)

---

## References

- **Full testing guide**: `tests/AGENTS.md`
- **Fixture catalog**: `tests/conftest.py`
- **Testing hygiene**: `.cursor/rules/101-testing-hygiene.mdc`
- **DRY principles**: `.cursor/rules/102-dry-principles.mdc`
- **Plan execution**: `.cursor/rules/104-plan-execution-hygiene.mdc`

---

## Summary: Non-Negotiable Rules

1. ✅ **MUST** use `make_semantic_layer` for SemanticLayer instances
2. ✅ **MUST** use `make_cohort_with_categorical` for categorical cohorts
3. ✅ **MUST** use `make_multi_table_setup` for 3-table tests
4. ✅ **MUST** use `mock_semantic_layer` for mocked semantic layers
5. ✅ **MUST** search `conftest.py` before creating any fixture
6. ✅ **MUST** use `make test-fast` (never `pytest` directly)
7. ✅ **MUST** run `make format && make lint-fix` before commit
8. ✅ **MUST** run `make check-fast` to verify changes

**Violations = Rejected changes. No exceptions.**
