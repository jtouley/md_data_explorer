# Test Fixture Enforcement

**Status**: MANDATORY - Enforced starting 2025-01 (Phase 1-2 Refactoring)

**Audience**: AI agents, code reviewers, developers

**Purpose**: Eliminate fixture duplication and enforce single source of truth

---

## Hard Rule: Factory Fixtures MUST Be Used

### ✅ REQUIRED Factory Fixtures

These fixtures are **MANDATORY**. Using them is **NOT OPTIONAL**.

#### 1. `make_semantic_layer` - SemanticLayer Factory

**When to use**: ANY test that creates a SemanticLayer instance

**Signature**:
```python
make_semantic_layer(
    dataset_name: str = "test_dataset",
    data: dict[str, list] | None = None,
    config_overrides: dict | None = None,
    workspace_name: str = "test_workspace",
) -> SemanticLayer
```

**Example**:
```python
def test_query_execution(make_semantic_layer):
    layer = make_semantic_layer(
        dataset_name="patients",
        data={"patient_id": [1, 2, 3], "age": [45, 62, 38]},
        config_overrides={
            "column_mapping": {"patient_id": "patient_id"},
            "outcomes": {"mortality": {"column": "died"}},
        },
    )
    result = layer.execute_query(...)
```

**❌ FORBIDDEN Alternative**:
```python
# WRONG - Will be REJECTED
def test_query_execution(tmp_path):
    workspace = tmp_path / "workspace"
    workspace.mkdir()
    config_path = workspace / "config.yaml"
    # ... 30 lines of setup ...
    layer = SemanticLayer(dataset_name="patients", ...)
```

---

#### 2. `mock_semantic_layer` - Mock SemanticLayer Factory

**When to use**: Tests that need semantic layer interface but not real data loading

**Signature**:
```python
mock_semantic_layer(
    columns: dict[str, str] | None = None,
) -> MagicMock
```

**Example**:
```python
def test_query_intent_conversion(mock_semantic_layer):
    mock = mock_semantic_layer(columns={"age": "age", "status": "status"})
    intent = QueryIntent(operation="describe", target="age")
    plan = intent_to_plan(intent, mock)
```

**❌ FORBIDDEN Alternative**:
```python
# WRONG - Will be REJECTED
def test_query_intent_conversion():
    mock = MagicMock()
    mock.get_canonical_column_name.side_effect = lambda x: x
    # ... duplicated mock setup ...
```

---

#### 3. `make_cohort_with_categorical` - Categorical Cohort Factory

**When to use**: Tests requiring patient cohorts with categorical encoding ("1: Yes", "2: No")

**Signature**:
```python
make_cohort_with_categorical(
    patient_ids: list[str] | None = None,
    treatment: list[str] | None = None,
    status: list[str] | None = None,
    ages: list[int] | None = None,
) -> pl.DataFrame
```

**Example**:
```python
def test_categorical_analysis(make_cohort_with_categorical):
    cohort = make_cohort_with_categorical(
        patient_ids=["P001", "P002"],
        treatment=["1: Yes", "2: No"],
        ages=[45, 52],
    )
    result = analyze_categorical(cohort)
```

**❌ FORBIDDEN Alternative**:
```python
# WRONG - Will be REJECTED
def test_categorical_analysis():
    cohort = pl.DataFrame({
        "patient_id": ["P001", "P002"],
        "treatment": ["1: Yes", "2: No"],
        "age": [45, 52],
    })
```

---

#### 4. `make_multi_table_setup` - Multi-Table Factory

**When to use**: Tests requiring patients, medications, and bridge table (patient_medications)

**Signature**:
```python
make_multi_table_setup(
    num_patients: int = 3,
    num_medications: int = 3,
) -> dict[str, pl.DataFrame]
```

**Returns**: `{"patients": df, "medications": df, "patient_medications": df}`

**Example**:
```python
def test_relationship_detection(make_multi_table_setup):
    tables = make_multi_table_setup(num_patients=5, num_medications=4)
    detector = RelationshipDetector(tables)
    relationships = detector.detect_all()
```

**❌ FORBIDDEN Alternative**:
```python
# WRONG - Will be REJECTED
def test_relationship_detection():
    patients = pl.DataFrame({"patient_id": ["P1", "P2"], ...})
    medications = pl.DataFrame({"medication_id": ["M1", "M2"], ...})
    patient_medications = pl.DataFrame({"patient_id": ["P1"], ...})
    tables = {"patients": patients, ...}
```

---

## Enforcement Protocol

## Mandatory Fixture Extraction Rule

### When Setup Code Is Duplicated

**CRITICAL**: If ANY test setup code appears in 2+ test functions, it MUST be extracted to a fixture.

**MANDATORY CHECKLIST**:

1. **Before writing test code**: Identify all setup steps (Arrange phase)
2. **If setup appears in 2+ tests**: ✅ Extract to fixture immediately
3. **If setup is similar but not identical**: ✅ Create factory fixture with parameters
4. **If setup is unique to one test**: ✅ Keep inline (but consider if it will be reused)

**Violation Examples**:

**❌ WRONG** (Will be REJECTED):
```python
class TestExternalPdfJsonSerialization:
    def test_save_table_list_removes_external_pdf_bytes(self, tmp_path):
        # Duplicate setup
        storage = UserDatasetStorage(tmp_path / "uploads")
        tables = [{"name": "test_table", "data": pl.DataFrame(...)}]
        metadata = {"dataset_name": "test", "external_pdf_bytes": b"..."}
        # ... test code ...

    def test_save_table_list_metadata_json_serializable(self, tmp_path):
        # DUPLICATE setup - VIOLATION!
        storage = UserDatasetStorage(tmp_path / "uploads")
        tables = [{"name": "test_table", "data": pl.DataFrame(...)}]
        metadata = {"dataset_name": "test", "external_pdf_bytes": b"..."}
        # ... test code ...
```

**✅ CORRECT** (REQUIRED):
```python
# Module-level fixtures (shared across test class)
@pytest.fixture
def upload_storage(tmp_path):
    """Create UserDatasetStorage with temp directory."""
    return UserDatasetStorage(upload_dir=tmp_path / "uploads")

@pytest.fixture
def sample_test_tables():
    """Standard test tables fixture."""
    return [{"name": "test_table", "data": pl.DataFrame(...)}]

@pytest.fixture
def make_metadata_with_external_pdf():
    """Factory fixture for creating metadata with external PDF."""
    def _make(dataset_name="test", pdf_content=b"...", pdf_filename="test.pdf"):
        return {"dataset_name": dataset_name, "external_pdf_bytes": pdf_content, ...}
    return _make

class TestExternalPdfJsonSerialization:
    def test_save_table_list_removes_external_pdf_bytes(
        self, upload_storage, sample_test_tables, make_metadata_with_external_pdf
    ):
        metadata = make_metadata_with_external_pdf()
        # ... test code uses fixtures ...

    def test_save_table_list_metadata_json_serializable(
        self, upload_storage, sample_test_tables, make_metadata_with_external_pdf
    ):
        metadata = make_metadata_with_external_pdf()
        # ... test code uses fixtures ...
```

### Rule of Two

**If setup code appears in 2+ places, extract to fixture. No exceptions.**

**Rationale**:
- **Single source of truth**: Setup logic exists in ONE place
- **Maintainability**: Changes require ONE update
- **Test clarity**: Tests focus on behavior, not setup
- **DRY compliance**: Eliminates duplicate code

### Common Patterns Requiring Extraction

1. **Storage/Service Initialization**: `UserDatasetStorage`, `DataStore`, etc.
   - ✅ Extract to `upload_storage`, `datastore` fixtures
   - ❌ Never create inline in multiple tests

2. **Test Data Creation**: DataFrames, tables, metadata
   - ✅ Extract to `sample_*` fixtures or `make_*` factories
   - ❌ Never duplicate DataFrame creation

3. **Mock Setup**: Complex mock configurations
   - ✅ Extract to `mock_*` fixtures
   - ❌ Never duplicate mock setup code

4. **File/Path Setup**: Temporary directories, file creation
   - ✅ Extract to fixtures using `tmp_path`
   - ❌ Never duplicate path setup

### Pre-Commit Hook Enforcement

**Automatic Detection**: Pre-commit hook (`scripts/check_test_fixtures.py`) automatically detects:
- Inline `UserDatasetStorage` creation in test functions
- Duplicate `pl.DataFrame` creation patterns
- Missing fixture usage for known patterns

**Run manually**:
```bash
make pre-commit-check  # Check all test files
```

**Pre-commit hook** (if installed):
```bash
pre-commit run check-test-fixtures  # Check staged files only
```

**If hook fails**: Extract duplicate setup to fixtures before committing.

### Before Creating ANY Fixture

**MANDATORY CHECKLIST**:

1. Open `tests/conftest.py`
2. Search for similar fixture names:
   - `make_*` (factory fixtures)
   - `sample_*` (direct fixtures)
   - `mock_*` (mock fixtures)
3. If fixture exists → **STOP. Use it.**
4. If fixture almost matches → **STOP. Use parameters/arguments.**
5. Only if truly unique → Create new fixture in `conftest.py`

### Before Creating ANY Test Data

**MANDATORY CHECKLIST**:

1. Check if factory fixture exists for this data type
2. If SemanticLayer → ✅ Use `make_semantic_layer`
3. If categorical cohort → ✅ Use `make_cohort_with_categorical`
4. If multi-table setup → ✅ Use `make_multi_table_setup`
5. If mock semantic layer → ✅ Use `mock_semantic_layer`
6. **NEVER create inline data when factory exists**

### Before Running Tests

**MANDATORY COMMANDS**:

```bash
# CORRECT - REQUIRED
make test-fast         # Fast tests during development
make test-core         # Core module tests
make test-analysis     # Analysis module tests

# WRONG - FORBIDDEN
pytest tests/
uv run pytest tests/
python -m pytest tests/
```

### Before Asserting DataFrame Equality

**MANDATORY: Use `pl.testing.assert_frame_equal()` for DataFrame comparisons**

**CHECKLIST**:

1. If comparing **entire DataFrames**: ✅ Use `pl.testing.assert_frame_equal(df1, df2)`
2. If comparing **single values**: ✅ Use `assert result == value`
3. If comparing **simple lists**: ✅ Use `assert [1, 2, 3] == [1, 2, 3]`
4. **NEVER use list comparisons for DataFrame columns**: ❌ `assert df1["col"].to_list() == df2["col"].to_list()`
5. **NEVER use pandas assertions**: ❌ `pd.testing.assert_frame_equal()` (pandas is prohibited)

**Example**:

```python
import polars.testing as plt

# ✅ CORRECT - Comprehensive DataFrame comparison
def test_transformation_produces_correct_output():
    input_df = pl.DataFrame({"id": [1, 2, 3], "value": [10, 20, 30]})
    result = transform(input_df)
    expected = pl.DataFrame({"id": [1, 2, 3], "value": [20, 40, 60]})
    plt.assert_frame_equal(result, expected)

# ❌ WRONG - Misses schema/type differences
def test_transformation_produces_correct_output():
    input_df = pl.DataFrame({"id": [1, 2, 3], "value": [10, 20, 30]})
    result = transform(input_df)
    expected = pl.DataFrame({"id": [1, 2, 3], "value": [20, 40, 60]})
    assert result["value"].to_list() == expected["value"].to_list()  # NO!

# ❌ WRONG - Pandas is prohibited
import pandas.testing as pdt
pdt.assert_frame_equal(result_df, expected_df)  # NO!
```

**Why**: `assert_frame_equal()` properly handles:
- Schema differences (missing/extra columns)
- Type mismatches (int vs float vs string)
- Null value semantics
- Float precision issues
- Column order differences

**When List Comparison is OK**:
- Single scalar value: `assert result == 42`
- Simple list of scalars: `assert [1, 2, 3] == [1, 2, 3]`
- String content: `assert "error message" in str(exception)`

### Before Committing

**MANDATORY PRE-COMMIT SEQUENCE**:

```bash
make format           # Auto-format code
make lint-fix         # Auto-fix linting issues
make pre-commit-check  # Check for duplicate test setup (NEW)
make check-fast        # Verify all quality gates
```

**If `make pre-commit-check` fails → Extract duplicate setup to fixtures before commit.**
**If `make check-fast` fails → Fix issues before commit. No exceptions.**

---

## Violation Examples with Corrections

### Violation 1: Inline SemanticLayer Creation

**❌ WRONG** (Will be REJECTED):
```python
def test_query_execution(tmp_path):
    workspace = tmp_path / "workspace"
    workspace.mkdir()
    config = {
        "dataset": {"name": "test"},
        "column_mapping": {},
        "init_params": {"source_path": str(tmp_path / "data.csv")},
    }
    config_path = workspace / "test_dataset" / "config.yaml"
    config_path.parent.mkdir(parents=True)
    with open(config_path, "w") as f:
        yaml.dump(config, f)
    
    layer = SemanticLayer(
        dataset_name="test",
        workspace_root=workspace,
    )
    # ... test code ...
```

**✅ CORRECT** (REQUIRED):
```python
def test_query_execution(make_semantic_layer):
    layer = make_semantic_layer(
        dataset_name="test",
        data={"patient_id": [1, 2, 3], "age": [45, 62, 38]},
    )
    # ... test code ...
```

---

### Violation 2: Duplicate Mock Setup

**❌ WRONG** (Will be REJECTED):
```python
# In test_queryplan_conversion.py
@pytest.fixture
def mock_semantic_layer():
    mock = MagicMock()
    mock.get_canonical_column_name.side_effect = lambda x: x
    return mock

# In test_nl_query_engine.py
@pytest.fixture
def mock_semantic_layer():  # DUPLICATE!
    mock = MagicMock()
    mock.get_canonical_column_name.side_effect = lambda x: x
    return mock
```

**✅ CORRECT** (REQUIRED):
```python
# Both files use conftest.py fixture
def test_conversion(mock_semantic_layer):
    mock = mock_semantic_layer(columns={"age": "age"})
    # ... test code ...

def test_nl_query(mock_semantic_layer):
    mock = mock_semantic_layer(columns={"status": "status"})
    # ... test code ...
```

---

### Violation 3: Hardcoded Multi-Table Setup

**❌ WRONG** (Will be REJECTED):
```python
def test_bridge_detection():
    patients = pl.DataFrame({
        "patient_id": ["P1", "P2", "P3"],
        "name": ["Alice", "Bob", "Charlie"],
        "age": [30, 45, 28],
    })
    medications = pl.DataFrame({
        "medication_id": ["M1", "M2", "M3"],
        "drug_name": ["Aspirin", "Metformin", "Lisinopril"],
        "dosage": ["100mg", "500mg", "10mg"],
    })
    patient_medications = pl.DataFrame({
        "patient_id": ["P1", "P1", "P2", "P3"],
        "medication_id": ["M1", "M2", "M1", "M3"],
        "start_date": ["2024-01-01", "2024-01-15", "2024-02-01", "2024-03-01"],
    })
    tables = {
        "patients": patients,
        "medications": medications,
        "patient_medications": patient_medications,
    }
    # ... test code ...
```

**✅ CORRECT** (REQUIRED):
```python
def test_bridge_detection(make_multi_table_setup):
    tables = make_multi_table_setup(num_patients=3, num_medications=3)
    # ... test code ...
```

---

## Code Review Checklist

**Before approving ANY test PR:**

- [ ] No duplicate fixtures across test files?
- [ ] All SemanticLayer instances use `make_semantic_layer`?
- [ ] All categorical cohorts use `make_cohort_with_categorical`?
- [ ] All multi-table tests use `make_multi_table_setup`?
- [ ] All mock semantic layers use `mock_semantic_layer`?
- [ ] No inline test data when factory exists?
- [ ] All tests run via `make` commands (not `pytest` directly)?
- [ ] `make check-fast` passes?

**If ANY checkbox is unchecked → Request changes.**

---

## Rationale

### Why Factory Fixtures Are Mandatory

1. **Single Source of Truth**: Fixture logic exists in ONE place
2. **Maintainability**: Changes to test data structure require ONE update
3. **Readability**: Tests focus on behavior, not setup
4. **DRY Compliance**: Eliminates 50+ lines of duplicate setup code per test
5. **Velocity**: Writing new tests is 10x faster with factories

### Why Makefile Commands Are Mandatory

1. **Consistency**: Same commands across all environments
2. **Optimization**: Makefile sets `-n auto` for parallel execution
3. **Dependencies**: Makefile ensures `uv sync` runs first
4. **CI Alignment**: Local and CI use identical commands

### Impact Metrics (2025-01 Refactoring)

- **Lines eliminated**: 500+ (duplicate fixture code)
- **Tests refactored**: 50+ (semantic layer, multi-table)
- **Fixtures consolidated**: 8 duplicates removed
- **Test speed**: 40% faster (parallel execution enabled)
- **Maintenance burden**: 75% reduction (single source of truth)

---

## References

- **Full testing guide**: `tests/AGENTS.md`
- **Fixture catalog**: `tests/conftest.py`
- **Testing hygiene**: `.cursor/rules/101-testing-hygiene.mdc`
- **DRY principles**: `.cursor/rules/102-dry-principles.mdc`
- **Plan execution**: `.cursor/rules/104-plan-execution-hygiene.mdc`

---

## Summary: Non-Negotiable Rules

1. ✅ **MUST** use `make_semantic_layer` for SemanticLayer instances
2. ✅ **MUST** use `make_cohort_with_categorical` for categorical cohorts
3. ✅ **MUST** use `make_multi_table_setup` for 3-table tests
4. ✅ **MUST** use `mock_semantic_layer` for mocked semantic layers
5. ✅ **MUST** search `conftest.py` before creating any fixture
6. ✅ **MUST** use `make test-fast` (never `pytest` directly)
7. ✅ **MUST** run `make format && make lint-fix` before commit
8. ✅ **MUST** run `make check-fast` to verify changes

**Violations = Rejected changes. No exceptions.**
